/*

A container has:

 - services it provides
 - plugins it's running
 - a way to accept connections (unix socket)
 - a map of all containers and services
 - a router to route requests within itself or to other containers

The master process can contain a container too.  It works no different except
for bootstrapping.

*/

var net = require('net');
var protocol = require('remoteagent-protocol');

// Export listen for when the master process wants a container
exports.listen = listen;


// For the child_process spawn case, the code is self starting.
// SOCKET_PATH is the name of this container
if (process.env.SOCKET_PATH) {
  listen(process.env.SOCKET_PATH, function (err, functions) {
    if (err) throw err;
    // Tell our parent we're initialized.
    process.stdin.write("\0");
  })
}

function listen(socketPath, callback) {
  var map = {};
  var services = {};
  var plugins = {};
  var connections = {};
  var name;

  function setMap(newMap) { map = newMap; }
  function die(code) { process.exit(code); }

  function configure(config, callback) {
    name = config.name;
    config.title && (process.title = config.title);
    config.gid && process.setgid(config.gid);
    config.uid && process.setuid(config.uid);
    callback();
  }

  function startPlugin(name, source, config, callback) {
  }

  function stopPlugin(name, callback) {
  }

  function handleRequest(serviceName, methodName, args) {
  }

  function makeRequest(serviceName, methodName, args) {
  }

  // Start accepting new connections on a local unix TCP socket
  var functions = {
    setMap: setMap,
    die: die,
    configure: configure,
    startPlugin: startPlugin,
    stopPlugin: stopPlugin,
    handleRequest: handleRequest,
  };

  var server = net.createServer(function (socket) {
    protocol.startClient(socket, socket, functions);
  });

  server.listen(socketPath, function (err) {
    if (err) return callback(err);
    callback(null, functions);
  });;

}
